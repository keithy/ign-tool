#!/usr/bin/env bash

# The groan framework is implemented by a minimal set of scripts.
# All top-level "commands" are exactly the same code but with differing names.
# i.e. `rename-to-your-command-name` and `groan\groan` are identical.
#
# This "Command" script - Provides basic features and redirects `groan <cmd>` to `<cmd>.sub.sh`

# our contribution to help
optionsLongForm=\
"--help    | -h | -?  Usage help for a command
--quiet   | -q       Quiet mode - say nothing
--verbose | -V       Verbose
--debug   | -D       Debug - tell all
--dry-run            # default
--confirm            # not a dry run - perform action
--theme=light        # select an alternate colour theme"

commonOptionsLong=\
"--help --quiet --verbose --debug"
commonOptionsShort=\
"-h     -q      -V        -D"
# STRICT-MODE

# http://redsymbol.net/articles/unofficial-bash-strict-mode/
set -euo pipefail
IFS=$'\n\t'
shopt -s nullglob # make sure globs are empty arrays if nothing is found
set -o allexport
NL=$'\n'

# FUNCTIONS

function g_identifyPlatform
{
    MACOSX=false
    WINDOWS=false
    LINUX=false

    if [[  -d "/System/Library/Frameworks" ]] ; then
		g_system=$(uname)
        MACOSX=true
    elif [ -d "/WINDOWS" ] ; then
        WINDOWS=true
    else
		g_system=$(uname)
        UNIX=true
        export $(cat /etc/os-release)
    fi
}

function g_needsSudo() {
    local prompt
    prompt=$(sudo -nv 2>&1)
    if [ $? -eq 0 ]; then
       $DEBUG && echo "User has 'sudo' access."
    elif echo $prompt | grep -q '^sudo:'; then
       $DEBUG && echo "User has sudo (password required)"
    else
       echo "this action requires `sudo` access."
       exit 1
    fi
}

function g_readLocations # from g_locations file
{
  c_file="$1"
  c_dir=$(dirname "$c_file")
  c_name="${c_file##*/}" # `basename $c_file` 

  g_locations=("${c_file}.commands") #default
  g_default_subcommand="_default" #default
  g_default_dispatch="_dispatch.sh"

  #c_dir c_name globals used within <name>.locations.sh file

  g_locations_config="${c_file}.locations.sh"

  if [ -f "$g_locations_config" ]; then  
    $DEBUG && echo "Locations< $g_locations_config"
    source "$g_locations_config"
  else 
    $DEBUG && echo "LocationsX $g_locations_config"
  fi
  return 0
}

function g_readConfig # from the first of the g_config_file_locations listed in the g_locations file
{
	for g_config_file in "${g_config_file_locations[@]:-}"
    do
        $DEBUG && echo "Config? $g_config_file"
        if [[ -f "$g_config_file" ]]; then
                $VERBOSE && echo "Config< $g_config_file"
                source "$g_config_file"
                break
        fi
    done
}

function g_readThemes # from 
{
  local g_theme_file
  bold=$''; dim=$''; bold=$''; reset=$''
  for g_theme_file in "${g_theme_path[@]:-}"
    do
        if [[ -f "$g_theme_file" ]]
        then
            $DEBUG && echo "Theme< $g_theme_file"
            source "$g_theme_file"
        else
            $DEBUG && echo "ThemeX $g_theme_file"
        fi
    done

  return 0
}

# Args: "${args[@]:+${args[@]}}" # pattern needed when set -u is enabled bash<=4.1
 
function g_executeScriptPath {

  s_path="$1"

  local title="Running"
  $METADATAONLY && title="Metadata<"

  case "${s_path##*.}" in
    sh)
        $DEBUG && echo "$title source> $s_path ${args[@]:+${args[@]}}"
        
        $XDEBUG && set -x
        g_sourceScriptMappingArgs "${args[@]:+${args[@]}}"
        if $XDEBUG; then set +x; fi #short && form does not agree with a following return
                
        return
    ;;
    exec)
        $DEBUG && echo "$title exec> $s_path ${args[@]:+${args[@]}}"
        exec "$s_path" "${args[@]:+${args[@]}}"
        return
    ;;
    su)
        $DEBUG && echo "$title exec> $s_path ${args[@]:+${args[@]}}"
        sudo "$s_path" "${args[@]:+${args[@]}}"
        return
    ;;
    *)
        $DEBUG && echo "Metadata< ${s_path/.sub.*/.meta.sh}"
        source "${s_path/.sub.*/.meta.sh}" "${args[@]:+${args[@]}}"

        $SHOWHELP && g_displayHelp
        $METADATAONLY && return

        $DEBUG && echo "Eval> $s_path ${args[@]:+${args[@]}}"
        eval "$s_path" "${args[@]:+${args[@]}}"
        exit 0
    ;;
  esac
}

#Sourcing a script is done via this function, so that args are mapped in to $@
function g_sourceScriptMappingArgs
{
    source "$s_path"
}

function g_displayHelp {
  printf "${bold}${brief:-$description}${reset}\n"
  [[ ! -z ${brief+x} ]] && printf "$description\n\n"
  [[ ! -z ${extra+x} ]] && printf "$extra\n\n"
  if [[ ! -z ${options+x} ]]; then
    printf "${bold}common:${reset} ${commonOptionsLong}\n${bold}options:${reset} ${commonOptionsShort}\n$options\n\n"
  else
    printf "${bold}options:${reset}\n${optionsLongForm}\n\n"
  fi
  printf "${bold}usage:${reset}\n${usage}\n"
  [[ ! -z ${help_postscript+x} ]] && printf "\n$help_postscript\n"
}

function g_checkForMarkdownViewer {
    # Check for Markdown Viewer
    [[ -z $(which "${g_markdown_viewer%% *}") ]] && g_markdown_viewer="cat"
    $DEBUG && echo "Markdown viewer: $g_markdown_viewer"
}

# This function should be easy but bash begs to differ: ${args[@]:1}
function g_shiftArgsIntoNext {
    next=""
    local params=()
    local arg

    if [[ "${#args[@]}" > 0 ]]; then
            for arg in "${args[@]}"
            do 
                    if [ -z "$next" ]; then
                            next="$arg"
                    else
                            params+=("$arg")
                    fi  
            done
    fi
    args=("${params[@]:+${params[@]}}")
}
 
# START

g_working_dir=$(pwd)

#find the $c_file and importantly the $c_dir
c_file="$(cd "${0%/*}" 2>/dev/null; echo "$PWD"/"${0##*/}")"
if [ -L "$c_file" ]; then
  c_file=$(readlink -n "$c_file")
fi

# Parsing options the groan way - initialize all flags to defaults

DEBUG=false
DDEBUG=false
XDEBUG=false
VERBOSE=false
LOUD=true
DRYRUN=true
CONFIRM=false
SHOWHELP=false     #exec command and only display the help metadata
METADATAONLY=false #exec command only as far as the help metadata
THEME=default

# Options processing pattern - search through the arguments for the command and flags

args=()
c_sub_cmd=""
for arg in "$@"
do
    case "$arg" in
      -DD|--ddebug)
            DDEBUG=true
      ;;
      -XX)
            XDEBUG=true
      ;;
      --debug | -D)
            DEBUG=true
            VERBOSE=true
            LOUD=true
      ;;
      --help | -h | "-?")
            SHOWHELP=true
            METADATAONLY=true
      ;;
      --verbose | --v | -v | -V )
            DEBUG=false
            VERBOSE=true
            LOUD=true
       ;;
      --quiet | -q)
            LOUD=false
            DEBUG=false
            VERBOSE=false
      ;;
      --dry-run | -dry | --dry)
            DRYRUN=true
            CONFIRM=false
      ;;
      --confirm)
            DRYRUN=false
            CONFIRM=true
      ;;
      --theme=*)
            THEME="${arg##--theme=}"
      ;;
      --*)
        args+=("$arg")
      ;;
      *)
          if [[ -z "$c_sub_cmd" ]]; then
             c_sub_cmd="$arg"
          else
             args+=("$arg")
          fi
      ;;
    esac
done
 
g_readLocations "$c_file"

breadcrumbs="$c_name"
g_root_cmd_file="$c_file"

g_readConfig
g_readThemes

$VERBOSE && echo "${bold}SCRIPT${reset}: $g_working_dir${dim}/${reset}${bold}$c_name${reset}"
 
! $DEBUG && $VERBOSE && [[ -f "$g_config_file" ]] && echo "Config< $g_config_file"
 
# handle the default empty case
[[ -z "$c_sub_cmd" ]] && c_sub_cmd="$g_default_subcommand"

$DEBUG && echo "Sub-command: '$c_sub_cmd'"

for s_dir in "${g_locations[@]}" 
do
    g_dispatcher="$s_dir/${g_default_dispatch}"
    if [ -f "$g_dispatcher" ]; then
      source "$g_dispatcher"
    fi
done

$LOUD && echo "Not Found: $breadcrumbs ${bold}$c_sub_cmd${reset}"
exit 1

# "This Code is distributed subject to the MIT License, as in http://www.opensource.org/licenses/mit-license.php . 
# Any additional contribution submitted for incorporation into or for distribution with this file shall be presumed
# subject to the same license."
